/******************************************************************************
    Copyright (c) 1996-2001 Synopsys, Inc.    ALL RIGHTS RESERVED

  The contents of this file are subject to the restrictions and limitations
  set forth in the SystemC Open Community License Software Download and
  Use License Version 1.2 (the "License"); you may not use this file except
  in compliance with such restrictions and limitations. You may obtain
  instructions on how to receive a copy of the License at
  http://www.systemc.org/. Software distributed by Original Contributor
  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF
  ANY KIND, either express or implied. See the License for the specific
  language governing rights and limitations under the License.

******************************************************************************/

/******************************************************************************

    sc_resolved_array_defs.h_ -- definitions for one dimensional arrays of 
				 signals of type T.

    Original Author: Abhijit Ghosh. Synopsys, Inc. (ghosh@synopsys.com)

******************************************************************************/

/******************************************************************************

    MODIFICATION LOG - modifiers, enter your name, affliation and
    changes you are making here:

    Modifier Name & Affiliation:
    Description of Modification:
    

******************************************************************************/


#ifndef SC_RESOLVED_ARRAY_DEFS_H
#define SC_RESOLVED_ARRAY_DEFS_H

template< class A, class R >
inline sc_signal_resolved_array<A,R>&
sc_signal_resolved_array<A,R>::sub( int i, int j )
{
    return dynamic_cast<ITEMPL2(sc_signal_resolved_array,A,R)&>(sc_array_base::sub(i,j));
}

/******************************************************************************
           DEFINITION OF PRIVATE AND PROTECTED MEMBER FUNCTIONS
******************************************************************************/

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>&
sc_signal_resolved_array_gnu<A,T,R>::write(const sc_array<T>& nv)
{
    int len = nv.length();
    this->check_length(len);

    for (int i = len - 1; i >= 0; --i) {
        sc_signal_resolved_t<T,R>* sig = (sc_signal_resolved_t<T,R> *) this->get_signal(i);
        sig->write(*(nv.get_data_ptr(i)));
    }
    return *this;
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>&
sc_signal_resolved_array_gnu<A,T,R>::write(const T* nv)
{
    for (int i = this->length() - 1; i >= 0; --i) {
        ((sc_signal_resolved_t<T,R> *) this->get_signal(i))->write(nv[i]);
    }
    return *this;
}

/******************************************************************************/

template< class A, class T, class R >
sc_array_base*
sc_signal_resolved_array_gnu<A,T,R>::vctor( const sc_array_base* p, int l, int r ) const
{
    return new sc_signal_resolved_array_gnu<A,T,R>( p, l, r );
}

/******************************************************************************
    This form of constructor is called only when a subranging operation is
    performed.  It does not allocate new data area; rather, it has a pointer
    into the data area of its `parent'.  The parent, in turn, keeps a list
    of children generated by subranging operations.
******************************************************************************/
template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( const sc_array_base* p, int l, int r ) 
    : A( p, l, r )
{
    // This should have been initialized
    assert(sc_signal_array_base::_length == A::length());
}

/*****************************************************************************************
       Constructors for concatenation 
******************************************************************************************/

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( sc_signal_resolved_array_gnu<A,T,R>* lhs,
                                                                   sc_signal_resolved_array_gnu<A,T,R>* rhs )
    : A( lhs, rhs )
{
    /* Intentionally Blank */
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( sc_signal_resolved_array_gnu<A,T,R>* lhs,
                                                                   sc_signal_resolved_t<T,R>* rhs )
    : A( lhs, rhs )
{
    /* Intentionally Blank */
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( sc_signal_resolved_t<T,R>* lhs,
                                                                   sc_signal_resolved_array_gnu<A,T,R>* rhs )
    : A( lhs, rhs )
{
    /* Intentionally Blank */
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( sc_signal_resolved_t<T,R>* lhs,
                                                                   sc_signal_resolved_t<T,R>* rhs )
    : A( lhs, rhs )
{
    /* Intentionally Blank */
}


/******************************************************************************
                 DEFINITION OF PUBLIC MEMBER FUNCTIONS
******************************************************************************/

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( int len,  sc_signal<T>* (*create_sig)(void *) )
    : A( len, create_sig )
{
    /* Intentionally Blank */
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( const char* nm, int len, 
                                                                   sc_signal<T>* (*create_sig)(void *) )
    : A( nm, len, create_sig )
{
    /* Intentionally Blank */
}

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( int len,
                                                                   const sc_signal_resolved_array_gnu<A,T,R>& ref )
    : A( len, (const A&) ref )
{
    /* Intentionally Blank */
}

// Prevent the use of the copy constructor
template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::sc_signal_resolved_array_gnu( const sc_signal_resolved_array_gnu<A,T,R>& ref )
    : A( ref )
{
    assert(false);
}

/******************************************************************************
                              DESTRUCTOR
*******************************************************************************/

template< class A, class T, class R >
sc_signal_resolved_array_gnu<A,T,R>::~sc_signal_resolved_array_gnu()
{
    /* The body is intentionally left empty since the object destruction is
       being done in the super class - Amit 3/2/99 */
}


/******************************************************************************
    sc_signal_resolved_array<A,R>::operator[](i) returns the signal indexed
    by (logical index) `i'.  It's done lazily, on demand.
******************************************************************************/
template< class A, class T, class R >
sc_signal<T>&
sc_signal_resolved_array_gnu<A,T,R>::subscript( int i )
{
    sc_signal<T>* sig = this->get_signal(i);
    return *sig;
}

template< class A, class T, class R >
inline sc_signal_resolved_t<T, R>&
sc_signal_resolved_array_gnu<A,T,R>::operator[]( int i )
{
    return dynamic_cast<resolved_sig_type&>( subscript(i) );
}

/******************************************************************************
    sub(i,j) returns a sc_signal_resolved_array<A,R>& that corresponds to
    the subrange (i,j) of the `parent' sc_signal_resolved_array.  Note that
    `i' may be greater than, smaller than, or equal to `j'.
******************************************************************************/
template< class A, class T, class R >
inline sc_signal_resolved_array_gnu<A,T,R>&
sc_signal_resolved_array_gnu<A,T,R>::sub( int i, int j )
{
    return dynamic_cast< this_type&>(sc_array_base::sub(i,j));
}

/*****************************************************************************
      Functions for sc_signal_resolved_array
******************************************************************************/

template< class A, class R >
sc_array_base*
sc_signal_resolved_array<A,R>::vctor( const sc_array_base* p, int l, int r ) const
{
    return new sc_signal_resolved_array<A,R>( p, l, r );
}

template< class A, class R > 
sc_array_base*
sc_signal_resolved_array<A,R>::new_array_vv( sc_array_base* x, sc_array_base* y )
{
    return new sc_signal_resolved_array<A,R>( (sc_signal_resolved_array<A,R>*) x, (sc_signal_resolved_array<A,R>*) y );
}

template< class A, class R >
sc_array_base*
sc_signal_resolved_array<A,R>::new_array_vs( sc_array_base* x, void* y )
{
    return new sc_signal_resolved_array<A,R>( (sc_signal_resolved_array<A,R>*) x, (sc_signal_resolved_t<T,R>*) y );
}

template< class A, class R >
sc_array_base*
sc_signal_resolved_array<A,R>::new_array_sv( void* x, sc_array_base* y )
{
    return new sc_signal_resolved_array<A,R>( (sc_signal_resolved_t<T,R>*) x, (sc_signal_resolved_array<A,R>*) y );
}

template< class A, class R >
sc_array_base*
sc_signal_resolved_array<A,R>::new_array_ss( void* x, void* y )
{
    return new sc_signal_resolved_array<A,R>( (sc_signal_resolved_t<T,R>*) x, (sc_signal_resolved_t<T,R>*) y );
}

#endif
